var f=Object.defineProperty;var w=(r,e,t)=>e in r?f(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var s=(r,e,t)=>(w(r,typeof e!="symbol"?e+"":e,t),t);function h(r){return r.isNode}class g{constructor(e,t){s(this,"isNode",!1);s(this,"n");s(this,"value");this.value=t,this.n=e}print(){return`Leaf(${this.n}, ${this.value})`}}class u{constructor(e,t,n){s(this,"isNode",!0);s(this,"n");s(this,"left");s(this,"right");this.n=e,this.left=t,this.right=n}print(){return`Node(${this.n})`}}function a(r){if(r.length>=3){const e=Math.ceil(r.length/2);return new u(r[e-1].n,a(r.slice(0,e)),a(r.slice(e)))}else{if(r.length===2)return new u(r[0].n,r[0],r[1]);if(r.length===1)return r[0];throw new Error("nodes.length === 0")}}class l{constructor(e){s(this,"root");const t=[...e].sort(([,n],[,o])=>n>o?1:n===o?0:-1);this.root=a(t.map(([n,o])=>new g(o,n)))}static fromRawLeafNodesUnsafe(e){return new l(e)}static fromRawLeafNodes(e){if(e.length===0)throw new Error("arr must be an array with at least one element");const t=typeof e[0][1];if(t!=="number"&&t!=="bigint"&&t!=="string")throw new Error("The node values must be a number, BigInt, or string.");if(!c(e))throw console.error("Array must be sorted in ascending order - each element must larger than the next.",e),new Error("Invalid array - not in ascending order");return new l(e)}static newNormalized(e,t){if(e.length===0)throw new Error("arr must be an array with at least one element");e[0][1]<0&&console.error("The first value must be larger than or equal to 0"),c(e)||console.error("Array must be sorted in ascending order - each element must be larger than the next.",e),t===void 0&&(t=e.reduce((o,i)=>i[1]+o,0));const n=Array.from(e.map(([o,i])=>[o,i/t]));return new l(n)}static newProportioned(e){if(e.length===0)throw new Error("arr must be an array with at least one element");const t=[];let n=0;return e.forEach(([o,i])=>{n+=i,t.push([o,n])}),new l(t)}static newProportionedNormalized(e){if(e.length===0)throw new Error("arr must be an array with at least one element");const t=[];let n=0;return e.forEach(([o,i])=>{n+=i,t.push([o,n])}),l.newNormalized(t,n)}search(e){let t=this.root;for(;h(t);)e<=t.n?t=t.left:t=t.right;return t.value}print(){let e=[this.root];for(;e.length>0;){let t="",n=[];for(let o=0;o<e.length;o++){const i=e[o];t+=i.print()+" ",h(i)&&(n.push(i.left),n.push(i.right))}console.log(t),e=n}}}function c(r){for(let e=0;e<r.length-1;e++)if(r[e][1]>r[e+1][1])return console.error(`index ${e} is larger than index ${e}`,r),!1;return!0}export{l as B};
